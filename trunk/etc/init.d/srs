#!/bin/bash

### BEGIN INIT INFO
# Provides:          simple-rtmp-server(srs)
# RequiRED-Start:    $all
# RequiRED-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: simple-rtmp-server(srs)
# Description:       https://github.com/winlinvip/simple-rtmp-server
### END INIT INFO

RED="\\e[31m"
GREEN="\\e[32m"
YELLOW="\\e[33m"
BLACK="\\e[0m"
POS="\\e[60G"

# the pid file is generated by install wizard
ROOT="./"
APP="./objs/srs"
CONFIG="./conf/srs.conf"
DEFAULT_PID_FILE='./objs/srs.pid'

ok_msg(){
    echo -e "${1}${POS}${BLACK}[${GREEN}  OK  ${BLACK}]"
}

failed_msg(){
    echo -e "${1}${POS}${BLACK}[${RED}FAILED${BLACK}]"
}

# load process info of srs
# @set variable $srs_pid to the process id in srs.pid file.
# @return 0, if process exists; otherwise:
#       1, for pid file not exists.
#       2, for get proecess info by pid failed.
# @set variable $error_msg if error.
# @set variable $srs_pid_file to pid file.
load_process_info() {
    srs_pid_file=`cat ${ROOT}/${CONFIG} |grep ^pid|awk '{print $2}'|awk -F ';' '{print $1}'`
    if [[ -z $srs_pid_file ]]; then srs_pid_file=${DEFAULT_PID_FILE}; fi
    
    srs_pid=`cat $srs_pid_file 2>/dev/null`
    ret=$?; if [[ 0 -ne $ret ]]; then error_msg="file $srs_pid_file does not exists"; return 1; fi
    
    ps -p ${srs_pid} >/dev/null 2>/dev/null
    ret=$?; if [[ 0 -ne $ret ]]; then error_msg="process $srs_pid does not exists"; return 2; fi
    
    return 0;
}

start() {
    # if exists, exit.
    load_process_info
    if [[ 0 -eq $? ]]; then
        failed_msg "srs started(pid ${srs_pid}), should not start it again."
        return 0
    fi
    
    # try to get log dir.
    
    # not exists, start server
    ok_msg "Starting srs..."
    # TODO: FIXME: set limit by, for instance, "ulimit -HSn 10000"
    # TODO: FIXME: write log to, for instance, the same dir of log.
    # TODO: FIXME: support deamon, without nohup.
    (cd ${ROOT}; nohup ${APP} -c ${CONFIG} >/dev/null 2>&1 &)
    
    # check again after start server
    load_process_info
    if [[ 0 -eq $? ]]; then
        ok_msg "srs started(pid ${srs_pid})"
    else
        failed_msg "srs not started"
    fi
}

stop() {
    # not start, exit
    load_process_info
    if [[ 0 -ne $? ]]; then
        failed_msg "srs not start."
        return 0
    fi
    
    ok_msg "Stopping srs(pid ${srs_pid})..."
    
    # process exists, kill util stop
    for((;;)); do
        load_process_info
        if [[ 0 -eq $? ]]; then
            kill -s SIGTERM ${srs_pid} 2>/dev/null
            ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "send signal SIGTERM failed ret=$ret"; return $ret; fi
            sleep 0.1
        else
            ok_msg "srs stopped"
            break;
        fi
    done
    
    sleep 0.1
    return 0
}

# get the status of srs process
# @return 0 if srs is running; otherwise, 1 for stopped.
status() {
    load_process_info
    ret=$?; if [[ 0 -eq $ret ]]; then
        echo "srs(pid ${srs_pid}) is running."
        return 0
    fi
    
    echo "srs is stopped, $error_msg"
    return 1
}

menu() {
    case "$1" in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            stop
            start
            ;;
        status)
            status
            ;;
        *)
            echo "Usage: $0 {start|stop|status|restart|reload}"
            return 1
            ;;
    esac
}

menu $1

code=$?
exit ${code}
